
    <header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">Using DOM APIs</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/components/dom-apis.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    
    <div class="docs-alert docs-alert-tip">
    <p><strong>Tip:</strong> This guide assumes you&#39;ve already read the <a href="essentials">Essentials Guide</a>. Read that first if you&#39;re new to Angular.</p>

    </div>
    <p>Angular handles most DOM creation, updates, and removals for you. However, you might rarely need to
directly interact with a component&#39;s DOM. Components can inject ElementRef to get a reference to the
component&#39;s host element:</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ProfilePhoto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">elementRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ElementRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(elementRef.nativeElement);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>The <code>nativeElement</code> property references the
host <a href="https://developer.mozilla.org/docs/Web/API/Element" target="_blank">Element</a> instance.</p>
<p>You can use Angular&#39;s <code>afterRender</code> and <code>afterNextRender</code> functions to register a <strong>render
callback</strong> that runs when Angular has finished rendering the page.</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ProfilePhoto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">elementRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ElementRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) {</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    afterRender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">      // Focus the first input element in this component.</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      elementRef.nativeElement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'input'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    });</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p><code>afterRender</code> and <code>afterNextRender</code> must be called in an <em>injection context</em>, typically a
component&#39;s constructor.</p>
<p><strong>Avoid direct DOM manipulation whenever possible.</strong> Always prefer expressing your DOM&#39;s structure
in component templates and updating that DOM with bindings.</p>
<p><strong>Render callbacks never run during server-side rendering or build-time pre-rendering.</strong></p>
<p><strong>Never directly manipulate the DOM inside of other Angular lifecycle hooks</strong>. Angular does not
guarantee that a component&#39;s DOM is fully rendered at any point other than in render callbacks.
Further, reading or modifying the DOM during other lifecycle hooks can negatively impact page
performance by
causing <a href="https://web.dev/avoid-large-complex-layouts-and-layout-thrashing" target="_blank">layout thrashing</a>.</p>

  <h2 id="using-a-components-renderer">
    <a href="#using-a-components-renderer" class="docs-anchor" tabindex="-1" aria-label="Link to Using a component&#39;s renderer">Using a component&#39;s renderer</a>
  </h2>
  <p>Components can inject an instance of <code>Renderer2</code> to perform certain DOM manipulations that are tied
to other Angular features.</p>
<p>Any DOM elements created by a component&#39;s <code>Renderer2</code> participate in that
component&#39;s <a href="guide/components/styling#style-scoping">style encapsulation</a>.</p>
<p>Certain <code>Renderer2</code> APIs also tie into Angular&#39;s animation system. You can use the <code>setProperty</code>
method to update synthetic animation properties and the <code>listen</code> method to add event listeners for
synthetic animation events. See the <a href="guide/animations">Animations</a> guide for details.</p>
<p>Aside from these two narrow use-cases, there is no difference between using <code>Renderer2</code> and native
DOM APIs. <code>Renderer2</code> APIs do not support DOM manipulation in server-side rendering or build-time
pre-rendering contexts.</p>

  <h2 id="when-to-use-dom-apis">
    <a href="#when-to-use-dom-apis" class="docs-anchor" tabindex="-1" aria-label="Link to When to use DOM APIs">When to use DOM APIs</a>
  </h2>
  <p>While Angular handles most rendering concerns, some behaviors may still require using DOM APIs. Some
common use cases include:</p>

  <ul class="docs-list">
    <li>Managing element focus</li>
<li>Measuring element geometry, such as with <code>getBoundingClientRect</code></li>
<li>Reading an element&#39;s text content</li>
<li>Setting up native observers such
as <a href="https://developer.mozilla.org/docs/Web/API/MutationObserver" target="_blank"><code>MutationObserver</code></a>,
<a href="https://developer.mozilla.org/docs/Web/API/ResizeObserver" target="_blank"><code>ResizeObserver</code></a>, or
<a href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" target="_blank"><code>IntersectionObserver</code></a>.</li>

  </ul>
  <p>Avoid inserting, removing, and modifying DOM elements. In particular, <strong>never directly set an
element&#39;s <code>innerHTML</code> property</strong>, which can make your application vulnerable
to <a href="https://developer.mozilla.org/docs/Glossary/Cross-site_scripting" target="_blank">cross-site scripting (XSS) exploits</a>.
Angular&#39;s template bindings, including bindings for <code>innerHTML</code>, include safeguards that help
protect against XSS attacks. See the <a href="best-practices/security">Security guide</a> for details.</p>
